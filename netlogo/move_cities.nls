to-report determine-resistance-to-move
  
  let childrenresistance (length peopleList - 2) * rtm_resistancePerChild
  let tippingPoint rtm_TippingPointX + ((item ageAcc item 0 peopleList - 18) * rtm_AgeModifier)
  ifelse timeSinceMoving <= tippingPoint [
    report (1 - ((rtm_TippingPointY / tippingPoint) * timeSinceMoving)) + childrenresistance
  ][ifelse timeSinceMoving < rtm_PlateauPointX [
    report (rtm_TippingPointY + ((( rtm_PlateauPointY - rtm_TippingPointY ) / (rtm_PlateauPointX - tippingPoint)) * (timeSinceMoving - tippingPoint))) + childrenresistance
  ][
  report rtm_PlateauPointY + childrenresistance
  ]
  ]
  
  
end

to-report determine-city-attractiveness
  let cityAttractivenessListHouseholdPerPerson []
  let finalCityAttractivenessListHousehold [] 
  
  foreach peopleList[
    let person ?
    ;; Children do not get a choice in where to move
    if item ageAcc person >= 16 [
      let job (item jobAcc person)
      let cityAttractivenessList []
      forEach jobAttractivenessList[
        set cityAttractivenessList lput item (job - 1) ? cityAttractivenessList
        
      ] 
      set cityAttractivenessListHouseholdPerPerson lput cityAttractivenessList cityAttractivenessListHouseholdPerPerson
    ]
  ]      
  
  ;; Here we aggregate the attractiveness of the city per member of the household into a single household score. 
  let cityIterator 0
  while [cityIterator < noOfCities] [
    let cityAverage mean map [item cityIterator ?] cityAttractivenessListHouseholdPerPerson
    
    ;; Here we alter the attractiveness of the city based upon the distance from the current location to that city
    ;; For cities very closeby (less than 100 patches) people will move less likely, since it is easily commuted daily
    ;; For cities very far away (more than 250 patches) people will move less likely since it is too far (from family etc.)
    let minMovingDistance MinimalMovingDistance
    let maxMovingDistance MaximumMovingDistance
    let distToCity 0
    ifelse cityIdentifier = 0 [
      ;;set distToCity distance one-of patches with [cityIdentifier = cityIterator + 1]
      set distToCity item cityIterator distanceToCities
      ;;set distToCity 110 
    ][
    set distToCity distance-between-cities cityIdentifier (cityIterator + 1)
    ] 
    if distToCity < minMovingDistance [
      set cityAverage cityAverage - MinDistCityAttractiveness     
    ]
    
    if distToCity > maxMovingDistance[
      set cityAverage cityAverage - MaxDistCityAttractiveness
    ]
    
    
    set finalCityAttractivenessListHousehold lput cityAverage finalCityAttractivenessListHousehold
    set cityIterator cityIterator + 1 
  ]
  
  report finalCityAttractivenessListHousehold   
end

to determine-city-attractiveness-from-jobs
  set jobAttractivenessList []
  
  set jobAttractivenessList lput (list Job1Attractiveness Job2Attractiveness Job3Attractiveness Job4Attractiveness Job5Attractiveness Job6Attractiveness Job7Attractiveness) jobAttractivenessList
  let cityIterator 1
  while[cityIterator <= noOfCities] [
    let jobIterator 1
    let jobAttractivenessForCity []
    while [jobIterator <= 7][
      set jobAttractivenessForCity lput precision (determine-city-attractiveness-per-job cityIterator jobIterator) 2 jobAttractivenessForCity 
      set jobIterator jobIterator + 1
    ]
    set jobAttractivenessList lput jobAttractivenessForCity jobAttractivenessList    
    set cityIterator cityIterator + 1
  ]
  
  
end


to-report determine-city-attractiveness-per-job [$cityIdentifier $jobIdentifier]
  ifelse $jobIdentifier = 1[
    ;; Job in primary sector
    let householdsInCity count turtles-on patches with [cityIdentifier = $cityIdentifier]
    let fractionHouseholdsInCity householdsInCity / noOfHouseholds
    ifelse fractionHouseholdsInCity < PercHouseholdsInitialInCity / noOfCities[
      report 1 - (job1_TippingPointY / (PercHouseholdsInitialInCity / noOfcities)) * fractionHouseholdsInCity      
    ][
    report job1_TippingPointY - job1_TippingPointY * fractionHouseholdsInCity
    ]
    
  ][ifelse $jobIdentifier = 2[
    ;; Job in manufacturing
    let householdsInCity count turtles-on patches with [cityIdentifier = $cityIdentifier]
    let fractionHouseholdsInCity householdsInCity / noOfHouseholds
    ifelse fractionHouseholdsInCity < PercHouseholdsInitialInCity / noOfCities[
      report 1 - (job2_TippingPointY / (PercHouseholdsInitialInCity / noOfcities)) * fractionHouseholdsInCity      
    ][
    report job2_TippingPointY - job2_TippingPointY * fractionHouseholdsInCity
    ]
    
  ][ifelse $jobIdentifier = 3[
    ;; Job in services
    let peopleInService 0
    let peopleInCity 0
    ask turtles-on patches with [cityIdentifier = $cityIdentifier][
      set peopleInCity peopleInCity + length filter [item ageAcc ? > 18] peopleList
      set peopleInService peopleInService + NoOfpeopleInService
    ] 
    let fractionPeopleInService peopleInService / peopleInCity
    ifelse fractionPeopleInService < job3_TippingPointX[
      report 1 - (( 1 - job3_TippingPointY ) / job3_TippingPointX ) * fractionPeopleInService
      
    ][
    report ( ((job3_TippingPointY / ( 1 - job3_TippingPointX )) * job3_TippingPointX) + job3_TippingPointY) - ( job3_TippingPointY / ( 1 - job3_TippingPointX )) * fractionPeopleInService
    ]
  ][ifelse $jobIdentifier = 4[
    ;; Job in finance
    let householdsInCity turtles-on patches with [cityIdentifier = $cityIdentifier]
    let peopleInFinance 0
    let peopleInCity 0
    ask householdsInCity[
      set peopleInCity peopleInCity + length filter [item ageAcc ? > 18] peopleList
      set peopleInFinance peopleInFinance + NoOfpeopleInFinance
    ] 
    let fractionPeopleInFinance peopleInFinance / peopleInCity
    
    ifelse fractionPeopleInFinance < 0.04[
      report 1 - ( job4_TippingPointY / job5_TippingPointX ) * fractionPeopleInFinance
    ][
    report min (list job4_Max (job4_Modifier * fractionPeopleInFinance))
    ]
    
  ][ifelse $jobIdentifier = 5[
    ;; Job in IT
    let peopleInIT 0
    let peopleInCity 0
    ask turtles-on patches with [cityIdentifier = $cityIdentifier][
      set peopleInCity peopleInCity + length filter [item ageAcc ? > 18] peopleList
      set peopleInIT peopleInIT + NoOfpeopleInIT
    ] 
    let fractionPeopleInIT peopleInIT / peopleInCity
    ifelse fractionPeopleInIT < job5_TippingPointX [
      report 1 - ( job5_TippingPointY / job5_TippingPointX ) * fractionPeopleInIT
    ][
    report min (list job5_Max (job5_Modifier * fractionPeopleInIT))
    ]
    
    
  ][ifelse $jobIdentifier = 6[
    ;; job in non-profit
    let peopleInNonProfit 0
    let peopleInCity 0
    ask turtles-on patches with [cityIdentifier = $cityIdentifier][
      set peopleInCity peopleInCity + length filter [item ageAcc ? > 18] peopleList
      set peopleInNonProfit peopleInNonProfit + NoOfpeopleInNonProfit
    ] 
    let fractionPeopleInNonProfit peopleInNonProfit / peopleInCity
    
    ifelse fractionPeopleInNonProfit < 0.34[
      report 1 - (( 1 - job6_TippingPointY ) / job6_TippingPointX ) * fractionPeopleInNonProfit
      
    ][
    report ( ((job6_TippingPointY / ( 1 - job6_TippingPointX )) * job6_TippingPointX) + job6_TippingPointY) - ( job6_TippingPointY / ( 1 - job6_TippingPointX )) * fractionPeopleInNonProfit
    ]   
  ][ifelse $jobIdentifier = 7[
    ;; Jobless0
    report job7_Value
    
  ][]]]]]]]
  
end


to move-to-city [$cityIdentifier]
  move-to one-of patches with [cityIdentifier = $cityIdentifier]  
  let cityIterator 1
  set distanceToCities []
  while [cityIterator <= noOfCities][
    set distanceToCities lput distance one-of patches with [cityIdentifier = cityIterator] distanceToCities
    set cityIterator cityIterator + 1
  ]
  set noOfMovesCounter noOfMovesCounter + 1
  if noOfMovesCounter mod updateCityAttractivenessFreq  = 0 [
    print "recomputing cityAttractiveness"
    determine-city-attractiveness-from-jobs
  ]
end

